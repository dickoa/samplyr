---
title: "Survey Analysis with samplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Survey Analysis with samplyr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE, echo = FALSE}
library(samplyr)
library(dplyr)
library(survey)
```

## Overview

After drawing a sample with `samplyr`, you typically need to analyze it. This vignette covers the tools `samplyr` provides for inspecting samples and integrating with the `survey` package for design-based inference.

Design objects store deferred column references (bare column names in `stratify_by()` / `cluster_by()`), which are resolved against the frame when you validate or execute the design.

## Sample Summary

`summary()` gives a concise overview of a sample: the design specification, execution details, stratum allocation table, and weight diagnostics.

```{r}
library(samplyr)
library(dplyr)
library(survey)

data(kenya_health)

sample <- sampling_design() |>
  stratify_by(facility_type, alloc = "proportional") |>
  draw(n = 300) |>
  execute(kenya_health, seed = 1)

summary(sample)
```

The allocation table shows the population size ($N_h$), sample size ($n_h$), and sampling fraction ($f_h$) per stratum. The weight diagnostics report the Kish design effect and effective sample size.

## Exporting to the survey Package

`as_svydesign()` converts a `tbl_sample` into a `survey::svydesign()` object. It automatically maps strata, clusters, weights, and finite population corrections from the sampling metadata.

### Stratified design

```{r}
svy <- as_svydesign(sample)
svy

svymean(~staff_count, svy)
svytotal(~outpatient_visits, svy)
```

### Cluster design with PPS

For PPS without-replacement designs, `as_svydesign()` uses Brewer's variance approximation by default.

```{r}
data(niger_eas)

cluster_sample <- sampling_design() |>
  cluster_by(ea_id) |>
  draw(n = 50, method = "pps_brewer", mos = hh_count) |>
  execute(niger_eas, seed = 2)

svy_cluster <- as_svydesign(cluster_sample)
svymean(~hh_count, svy_cluster)
```

### Multi-stage design

For multi-stage designs, each stage's cluster variable maps to a level of the `id` formula. Strata are exported from the first stage, consistent with the standard with-replacement variance approximation (Cochran 1977, ch. 11).

```{r}
data(tanzania_schools)

schools_frame <- tanzania_schools |>
  mutate(district_enrollment = sum(enrollment), .by = district)

ms_sample <- sampling_design() |>
  add_stage(label = "Districts") |>
    stratify_by(region) |>
    cluster_by(district) |>
    draw(n = 2, method = "pps_brewer", mos = district_enrollment) |>
  add_stage(label = "Schools") |>
    draw(n = 3) |>
  execute(schools_frame, seed = 3)

svy_ms <- as_svydesign(ms_sample)
svy_ms
svymean(~enrollment, svy_ms)
```

## Replicate-Weight Export

For replicate-based variance estimation (jackknife/BRR/bootstrap), use `as_svrepdesign()`. This converts a `tbl_sample` to `svydesign`, then to `svyrep.design` using `survey::as.svrepdesign()`.

```{r}
rep_svy <- as_svrepdesign(sample, type = "auto")
svymean(~staff_count, rep_svy)
```

You can also export directly to a `srvyr` replicate design:

```{r}
library(srvyr)

rep_tbl <- as_survey_rep(sample, type = "auto")
rep_tbl |>
  summarise(mean_staff = survey_mean(staff_count, vartype = "se"))
```

Current scope: replicate export supports single-phase non-PPS designs. Two-phase and PPS designs should use `as_svydesign()` (linearization).

## Exact Variance with Joint Expectations

The Brewer approximation works well in practice, but if you need to use second-order quantities directly, `joint_expectation()` computes them for all PPS stages. For WOR stages, this produces joint inclusion probabilities (pi_kl). For WR/PMR stages (`pps_multinomial`, `pps_chromy`), it produces joint expected hits E(n_k * n_l). See `?joint_expectation` to see which methods provide exact second-order moments, which approximations are provided, and for the full method-by-method breakdown.

It replays the design specification against the original frame, computing quantities per stratum and assembling a block-diagonal matrix.

```{r}
pps_sample <- sampling_design() |>
  add_stage() |>
    stratify_by(region) |>
    cluster_by(ea_id) |>
    draw(n = 5, method = "pps_cps", mos = hh_count) |>
  add_stage() |>
    draw(n = 12) |>
  execute(niger_eas, seed = 2025)

# Compute joint probabilities for stage 1 (exact for CPS)
jip <- joint_expectation(pps_sample, niger_eas, stage = 1)

# Use with survey for exact variance (WOR stages)
svy_exact <- as_svydesign(pps_sample, pps = ppsmat(jip[[1]]))
svymean(~hh_count, svy_exact)

svy_brewer <- as_svydesign(pps_sample)
svymean(~hh_count, svy_brewer)
```

The supported methods :

| samplyr method    | `joint_expectation()` returns | Precision   |
|-------------------|-------------------------------|-------------|
| `pps_brewer`      | $\pi_{kl}$                    | Approximate |
| `pps_systematic`  | $\pi_{kl}$                    | Exact       |
| `pps_cps`         | $\pi_{kl}$                    | Exact       |
| `pps_poisson`     | $\pi_{kl}$                    | Exact       |
| `pps_sps`         | $\pi_{kl}$                    | Approximate |
| `pps_pareto`      | $\pi_{kl}$                    | Approximate |
| `pps_multinomial` | $E(n_k * n_l)$                | Exact       |
| `pps_chromy`      | $E(n_k * n_l)$                | Approximate |


## End-to-End Workflow

A complete workflow from design to estimates:

```{r}
# 1. Define the design
design <- sampling_design(title = "Kenya Health Facility Survey") |>
  stratify_by(facility_type, alloc = "proportional") |>
  draw(n = 300)

# 2. Validate the frame
validate_frame(design, kenya_health)

# 3. Draw the sample
sample <- execute(design, kenya_health, seed = 2026)

# 4. Inspect
summary(sample)

# 5. Export and analyze
svy <- as_svydesign(sample)
svymean(~staff_count, svy)
confint(svymean(~staff_count, svy))
```
