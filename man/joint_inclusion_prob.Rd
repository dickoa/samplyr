% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/joint.R
\name{joint_inclusion_prob}
\alias{joint_inclusion_prob}
\title{Compute joint inclusion probabilities from a sample and its frame}
\usage{
joint_inclusion_prob(x, frame, stage = NULL)
}
\arguments{
\item{x}{A \code{tbl_sample} object produced by \code{\link[=execute]{execute()}}.}

\item{frame}{The data frame originally passed to \code{\link[=execute]{execute()}}. Must
contain the same columns used during sampling (strata variables,
cluster variables, measure of size).}

\item{stage}{An integer vector of stage numbers to compute, or
\code{NULL} (default) to compute all PPS without replacement stages.
Non-PPS stages produce \code{NULL} entries in the returned list.}
}
\value{
A named list of length equal to the number of executed
stages. Each element is either:
\itemize{
\item A square matrix of joint inclusion probabilities for PPS WOR
stages, with dimensions matching the number of sampled units
at that stage (or sampled clusters for clustered stages).
Rows and columns are ordered to match the sample.
\item \code{NULL} for non-PPS stages (SRS, systematic, WR methods, PMR
methods) or stages not requested via the \code{stage} argument.
}
}
\description{
Reconstructs the joint inclusion probabilities \eqn{\pi_{kl}}{pi_kl} for PPS
without replacement stages by replaying the design specification
against the original sampling frame. This allows exact variance
estimation via \code{\link[survey:HR]{survey::ppsmat()}} instead of the default Brewer
approximation used by \code{\link[=as_survey_design]{as_survey_design()}}.
}
\details{
For each PPS without replacement stage, the function:
\enumerate{
\item Reconstructs the full-population inclusion probabilities \eqn{\pi_i}{pi_i}
from the frame using the stage's method and measure of size
\item Dispatches to the appropriate sondage joint probability function
\item Extracts the submatrix corresponding to sampled units
}

For stratified stages, the target sample size per stratum (n_h) is
reconstructed by replaying the same allocation logic used during
\code{\link[=execute]{execute()}} (proportional, Neyman, optimal, etc.) against the
frame. This ensures \eqn{\pi_i}{pi_i} values match what was computed at sampling
time, regardless of allocation method.

For stratified or conditional (within-cluster) stages, joint
probabilities are computed independently within each group and
assembled into a block-diagonal matrix.
\subsection{Method dispatch}{\tabular{ll}{
   samplyr method \tab sondage function \cr
   \code{pps_brewer} \tab \code{up_brewer_jip(pik)} \cr
   \code{pps_systematic} \tab \code{up_systematic_jip(pik)} \cr
   \code{pps_maxent} \tab \code{up_maxent_jip(pik)} \cr
   \code{pps_poisson} \tab \code{up_poisson_jip(pik)} \cr
}

}

\subsection{Chromy's sequential PPS method (PMR)}{

\code{pps_chromy} is excluded from joint probability computation.
Chromy's method is a \emph{Probability Minimum Replacement} (PMR)
method, not a standard WOR method. Units can receive multiple
hits, so the relevant pairwise quantities are expected sample
size products \eqn{E(n_i \cdot n_j)}{E(n_i * n_j)}, not inclusion probabilities \eqn{\pi_{ij}}{pi_ij}.

While sondage provides \code{up_chromy_pairexp()} to estimate \eqn{E(n_i \cdot n_j)}{E(n_i * n_j)}
via Monte Carlo, the result cannot be passed to \code{survey::ppsmat()}
because the survey package assumes the diagonal contains \eqn{\pi_i}{pi_i}, but
for PMR it contains \eqn{E(n_i^2) \neq E(n_i)}{E(n_i^2) != E(n_i)} when units receive multiple
hits. Chromy (2009) recommends the Hansen-Hurwitz approximation
for variance estimation, which is the default used by
\code{\link[=as_survey_design]{as_survey_design()}}.
}

\subsection{Limitations}{
\itemize{
\item Requires the original sampling frame. The frame must be unchanged
from what was passed to \code{\link[=execute]{execute()}}.
\item Units in the frame must be uniquely identifiable within each
stratum/cluster group by their column values.
\item For designs with certainty selections (\eqn{\pi_i = 1}{pi_i = 1}), the joint
matrix is decomposed: certainty units are separated from the
stochastic part, the joint probabilities for non-certainty units
are computed from the reduced \eqn{\pi}{pi} vector, and the full matrix is
reassembled with \eqn{\pi_{ij} = 1}{pi_ij = 1} for certainty pairs and
\eqn{\pi_{ij} = \pi_j}{pi_ij = pi_j} for certainty x non-certainty pairs.
}
}
}
\examples{
\dontrun{
sample <- sampling_design() |>
  add_stage() |>
    stratify_by(region) |>
    cluster_by(ea_id) |>
    draw(n = 5, method = "pps_brewer", mos = hh_count) |>
  add_stage() |>
    draw(n = 12) |>
  execute(niger_eas, seed = 2025)

# Compute joint probabilities for stage 1
jip <- joint_inclusion_prob(sample, niger_eas, stage = 1)

# Use with survey package for exact variance
svy <- as_survey_design(sample, pps = survey::ppsmat(jip[[1]]))

# Compute all PPS stages at once
jip_all <- joint_inclusion_prob(sample, niger_eas)
}

}
\seealso{
\code{\link[=as_survey_design]{as_survey_design()}} for the default export using Brewer's
approximation, \code{\link[survey:HR]{survey::ppsmat()}} for wrapping joint matrices
}
