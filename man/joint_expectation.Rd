% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/joint.R
\name{joint_expectation}
\alias{joint_expectation}
\title{Compute pairwise joint expectations from a sample and its frame}
\usage{
joint_expectation(x, frame, stage = NULL)
}
\arguments{
\item{x}{A \code{tbl_sample} object produced by \code{\link[=execute]{execute()}}.}

\item{frame}{The data frame originally passed to \code{\link[=execute]{execute()}}. Must
contain the same columns used during sampling (strata variables,
cluster variables, measure of size).}

\item{stage}{An integer vector of stage numbers to compute, or
\code{NULL} (default) to compute all PPS stages.
Non-PPS stages produce \code{NULL} entries in the returned list.}
}
\value{
A named list of length equal to the number of executed
stages. Each element is either:
\itemize{
\item For PPS WOR stages: a square matrix of joint inclusion
probabilities \eqn{\pi_{kl}}{pi_kl}, usable with
\code{\link[survey:HR]{survey::ppsmat()}} for exact variance estimation.
\item For PPS WR/PMR stages (\code{pps_multinomial}, \code{pps_chromy}): a
square matrix of joint expected hits
\eqn{E(n_k \cdot n_l)}{E(n_k * n_l)}.
\item \code{NULL} for non-PPS stages (SRS, systematic) or stages not
requested via the \code{stage} argument.
Dimensions match the number of unique sampled units (or sampled
clusters for clustered stages). Rows and columns are ordered to
match the sample.
}
}
\description{
Reconstructs the second-order design quantities for PPS stages by
replaying the design specification against the original sampling
frame. For without-replacement (WOR) stages, this produces the joint
inclusion probabilities \eqn{\pi_{kl}}{pi_kl}. For with-replacement
(WR) and PMR stages, this produces the joint expected hits
\eqn{E(n_k \cdot n_l)}{E(n_k * n_l)}.
}
\details{
For each PPS stage, the function:
\enumerate{
\item Reconstructs the full-population first-order quantities from
the frame using the stage's method and measure of size
\item Dispatches to the appropriate sondage joint probability or
joint expected hits function
\item Extracts the submatrix corresponding to sampled units
}

For stratified stages, the target sample size per stratum (n_h) is
reconstructed by replaying the same allocation logic used during
\code{\link[=execute]{execute()}} (proportional, Neyman, optimal, etc.) against the
frame. This ensures first-order quantities match what was computed
at sampling time, regardless of allocation method.

For stratified or conditional (within-cluster) stages, joint
quantities are computed independently within each group and
assembled into a block-diagonal matrix.
\subsection{Exact vs. approximate computation}{

The accuracy of the returned matrix depends on the sampling method.
Some algorithms yield closed-form joint probabilities; others
require approximation or simulation.
\subsection{WOR methods (\eqn{\pi_{kl}}{pi_kl})}{\tabular{lll}{
   samplyr method \tab sondage function \tab Quality \cr
   \code{pps_cps} \tab \code{joint_inclusion_prob()} \tab \strong{Exact} (Aires' formula via C) \cr
   \code{pps_systematic} \tab \code{joint_inclusion_prob()} \tab \strong{Exact} (combinatorial enumeration) \cr
   \code{pps_poisson} \tab \code{joint_inclusion_prob()} \tab \strong{Exact} (\eqn{\pi_{kl} = \pi_k \pi_l}{pi_kl = pi_k * pi_l}, independent draws) \cr
   \code{pps_brewer} \tab \code{joint_inclusion_prob()} \tab \strong{Approximate}\eqn{^*} (high-entropy / Hajek-Brewer-Donadio) \cr
   \code{pps_sps} \tab \code{joint_inclusion_prob()} \tab \strong{Approximate} (high-entropy / Hajek-Brewer-Donadio) \cr
   \code{pps_pareto} \tab \code{joint_inclusion_prob()} \tab \strong{Approximate} (high-entropy / Hajek-Brewer-Donadio) \cr
}


\eqn{^*} Exact recursive formulas for Brewer's joint inclusion
probabilities exist (Brewer 2002, ch. 9) but are
\eqn{O(N^3)}{O(N^3)}, making them impractical for frames of more
than a few hundred units. The high-entropy approximation is
\eqn{O(N^2)}{O(N^2)} and sufficiently accurate for variance
estimation in practice. The same trade-off applies to SPS and
Pareto, whose exact joint probabilities would require enumerating
the combinatorial sample space.

The high-entropy approximation assumes the design is close to the
maximum-entropy design with the same marginal \eqn{\pi_i}{pi_i}
(Hajek 1964; Brewer and Donadio 2003). This is a good approximation
for most PPS designs and is the same quantity that underlies the
Berger (2004) variance estimator used by \code{survey::svydesign(pps = "brewer")}. For CPS (conditional Poisson / maximum entropy), the
joint probabilities are exact by definition.
}

\subsection{WR/PMR methods (\eqn{E(n_k \cdot n_l)}{E(n_k * n_l)})}{\tabular{lll}{
   samplyr method \tab sondage function \tab Quality \cr
   \code{pps_multinomial} \tab \code{joint_expected_hits()} \tab \strong{Exact} (analytic: \eqn{n(n-1) p_k p_l + n p_k \mathbf{1}_{k=l}}{n(n-1) p_k p_l + n p_k 1(k=l)}) \cr
   \code{pps_chromy} \tab \code{joint_expected_hits()} \tab \strong{Approximate} (Monte Carlo simulation, 10 000 replicates) \cr
}


For \code{pps_chromy}, the sequential dependence structure does not admit
a closed-form expression for \eqn{E(n_k \cdot n_l)}{E(n_k * n_l)}.
sondage uses Monte Carlo simulation (default 10 000 replicates) to
estimate the pairwise expectations. Increasing \code{nsim} (passed
through \code{...}) reduces Monte Carlo error at the cost of computation
time.
}

}

\subsection{Limitations}{
\itemize{
\item Requires the original sampling frame. The frame must be unchanged
from what was passed to \code{\link[=execute]{execute()}}.
\item Units in the frame must be uniquely identifiable within each
stratum/cluster group by their column values.
\item For WOR designs with certainty selections (\eqn{\pi_i = 1}{pi_i = 1}),
the joint matrix is decomposed: certainty units are separated
from the stochastic part, the joint probabilities for
non-certainty units are computed from the reduced \eqn{\pi}{pi}
vector, and the full matrix is reassembled with
\eqn{\pi_{ij} = 1}{pi_ij = 1} for certainty pairs and
\eqn{\pi_{ij} = \pi_j}{pi_ij = pi_j} for certainty x
non-certainty pairs.
}
}
}
\examples{
\dontshow{if (requireNamespace("survey", quietly = TRUE)) withAutoprint(\{ # examplesIf}
sample <- sampling_design() |>
  add_stage() |>
    stratify_by(region) |>
    cluster_by(ea_id) |>
    draw(n = 5, method = "pps_brewer", mos = hh_count) |>
  add_stage() |>
    draw(n = 12) |>
  execute(niger_eas, seed = 2025)

# Compute joint probabilities for stage 1
jip <- joint_expectation(sample, niger_eas, stage = 1)

# Use with survey package for exact variance (WOR stages)
svy <- as_svydesign(sample, pps = survey::ppsmat(jip[[1]]))

# Compute all PPS stages at once
jip_all <- joint_expectation(sample, niger_eas)
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=as_svydesign]{as_svydesign()}} for the default export using Brewer's
approximation, \code{\link[survey:HR]{survey::ppsmat()}} for wrapping joint matrices
}
