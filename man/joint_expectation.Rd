% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/joint.R
\name{joint_expectation}
\alias{joint_expectation}
\title{Compute pairwise joint expectations from a sample and its frame}
\usage{
joint_expectation(x, frame, stage = NULL)
}
\arguments{
\item{x}{A \code{tbl_sample} object produced by \code{\link[=execute]{execute()}}.}

\item{frame}{The data frame originally passed to \code{\link[=execute]{execute()}}. Must
contain the same columns used during sampling (strata variables,
cluster variables, measure of size).}

\item{stage}{An integer vector of stage numbers to compute, or
\code{NULL} (default) to compute all PPS stages.
Non-PPS stages produce \code{NULL} entries in the returned list.}
}
\value{
A named list of length equal to the number of executed
stages. Each element is either:
\itemize{
\item For PPS WOR stages: a square matrix of joint inclusion
probabilities \eqn{\pi_{kl}}{pi_kl}, usable with
\code{\link[survey:HR]{survey::ppsmat()}} for exact variance estimation.
\item For PPS WR/PMR stages (\code{pps_multinomial}, \code{pps_chromy}): a
square matrix of joint expected hits
\eqn{E(n_k \cdot n_l)}{E(n_k * n_l)}.
\item \code{NULL} for non-PPS stages (SRS, systematic) or stages not
requested via the \code{stage} argument.
Dimensions match the number of unique sampled units (or sampled
clusters for clustered stages). Rows and columns are ordered to
match the sample.
}
}
\description{
Reconstructs the second-order design quantities for PPS stages by
replaying the design specification against the original sampling
frame. For without-replacement (WOR) stages, this produces the joint
inclusion probabilities \eqn{\pi_{kl}}{pi_kl}. For with-replacement
(WR) and PMR stages, this produces the joint expected hits
\eqn{E(n_k \cdot n_l)}{E(n_k * n_l)}.
}
\details{
For each PPS stage, the function:
\enumerate{
\item Reconstructs the full-population first-order quantities from
the frame using the stage's method and measure of size
\item Dispatches to the appropriate sondage joint probability or
joint expected hits function
\item Extracts the submatrix corresponding to sampled units
}

For stratified stages, the target sample size per stratum (n_h) is
reconstructed by replaying the same allocation logic used during
\code{\link[=execute]{execute()}} (proportional, Neyman, optimal, etc.) against the
frame. This ensures first-order quantities match what was computed
at sampling time, regardless of allocation method.

For stratified or conditional (within-cluster) stages, joint
quantities are computed independently within each group and
assembled into a block-diagonal matrix.
\subsection{WOR method dispatch}{\tabular{ll}{
   samplyr method \tab sondage function \cr
   \code{pps_brewer} \tab \code{joint_inclusion_prob()} \cr
   \code{pps_systematic} \tab \code{joint_inclusion_prob()} \cr
   \code{pps_cps} \tab \code{joint_inclusion_prob()} \cr
   \code{pps_poisson} \tab \code{joint_inclusion_prob()} \cr
   \code{pps_sps} \tab \code{joint_inclusion_prob()} \cr
   \code{pps_pareto} \tab \code{joint_inclusion_prob()} \cr
}

}

\subsection{WR/PMR method dispatch}{\tabular{ll}{
   samplyr method \tab sondage function \cr
   \code{pps_multinomial} \tab \code{joint_expected_hits()} \cr
   \code{pps_chromy} \tab \code{joint_expected_hits()} \cr
}

}

\subsection{Limitations}{
\itemize{
\item Requires the original sampling frame. The frame must be unchanged
from what was passed to \code{\link[=execute]{execute()}}.
\item Units in the frame must be uniquely identifiable within each
stratum/cluster group by their column values.
\item For WOR designs with certainty selections (\eqn{\pi_i = 1}{pi_i = 1}),
the joint matrix is decomposed: certainty units are separated
from the stochastic part, the joint probabilities for
non-certainty units are computed from the reduced \eqn{\pi}{pi}
vector, and the full matrix is reassembled with
\eqn{\pi_{ij} = 1}{pi_ij = 1} for certainty pairs and
\eqn{\pi_{ij} = \pi_j}{pi_ij = pi_j} for certainty x
non-certainty pairs.
}
}
}
\examples{
\dontrun{
sample <- sampling_design() |>
  add_stage() |>
    stratify_by(region) |>
    cluster_by(ea_id) |>
    draw(n = 5, method = "pps_brewer", mos = hh_count) |>
  add_stage() |>
    draw(n = 12) |>
  execute(niger_eas, seed = 2025)

# Compute joint probabilities for stage 1
jip <- joint_expectation(sample, niger_eas, stage = 1)

# Use with survey package for exact variance (WOR stages)
svy <- as_svydesign(sample, pps = survey::ppsmat(jip[[1]]))

# Compute all PPS stages at once
jip_all <- joint_expectation(sample, niger_eas)
}

}
\seealso{
\code{\link[=as_svydesign]{as_svydesign()}} for the default export using Brewer's
approximation, \code{\link[survey:HR]{survey::ppsmat()}} for wrapping joint matrices
}
