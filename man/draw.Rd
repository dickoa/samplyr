% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/draw.R
\name{draw}
\alias{draw}
\title{Specify Selection Parameters}
\usage{
draw(
  .data,
  n = NULL,
  frac = NULL,
  min_n = NULL,
  max_n = NULL,
  method = "srswor",
  mos = NULL,
  round = "up",
  control = NULL,
  certainty_size = NULL,
  certainty_prop = NULL
)
}
\arguments{
\item{.data}{A \code{sampling_design} object (piped from \code{\link[=sampling_design]{sampling_design()}},
\code{\link[=stratify_by]{stratify_by()}}, or \code{\link[=cluster_by]{cluster_by()}}).}

\item{n}{Sample size. Can be:
\itemize{
\item A scalar: applies per stratum (if no \code{alloc}) or as total (if \code{alloc} specified)
\item A named vector: stratum-specific sizes (for single stratification variable)
\item A data frame: stratum-specific sizes with stratification columns + \code{n} column
}}

\item{frac}{Sampling fraction. Can be:
\itemize{
\item A scalar: same fraction for all strata
\item A named vector: stratum-specific fractions
\item A data frame: stratum-specific fractions with stratification columns + \code{frac} column
Only one of \code{n} or \code{frac} should be specified.
}}

\item{min_n}{Minimum sample size per stratum. When an allocation method
(e.g., Neyman, proportional) would assign fewer than \code{min_n} units to a
stratum, that stratum receives \code{min_n} units instead. The excess is
redistributed proportionally among strata that were above \code{min_n}.
Commonly set to 2 (minimum for variance estimation) or higher for
reliable subgroup estimates. Only applies when stratification with an
allocation method is used. Default is \code{NULL} (no minimum).}

\item{max_n}{Maximum sample size per stratum. When an allocation method
would assign more than \code{max_n} units to a stratum, that stratum is
capped at \code{max_n} units. The surplus is redistributed proportionally
among strata that were below \code{max_n}. Useful for capping dominant strata
or managing operational constraints. Only applies when stratification
with an allocation method is used. Default is \code{NULL} (no maximum).}

\item{method}{Character string specifying the selection method. One of:

\strong{Equal probability methods:}
\itemize{
\item \code{"srswor"} (default): Simple random sampling without replacement
\item \code{"srswr"}: Simple random sampling with replacement
\item \code{"systematic"}: Systematic (fixed interval) sampling
\item \code{"bernoulli"}: Independent Bernoulli trials (random sample size)
}

\strong{PPS methods (require \code{mos}):}
\itemize{
\item \code{"pps_systematic"}: PPS systematic sampling
\item \code{"pps_brewer"}: Generalized Brewer (Tillé) method
\item \code{"pps_maxent"}: Maximum entropy / conditional Poisson
\item \code{"pps_poisson"}: PPS Poisson sampling (random sample size)
\item \code{"pps_multinomial"}: PPS multinomial (with replacement, any hit count)
\item \code{"pps_chromy"}: Chromy's sequential PPS (minimum replacement)
}}

\item{mos}{<\code{\link[dplyr:dplyr_data_masking]{data-masking}}> Measure of size
variable for PPS methods. Required for all \verb{pps_*} methods.}

\item{round}{Rounding method when converting \code{frac} to sample sizes.
One of:
\itemize{
\item \code{"up"} (default): Round up (ceiling). Matches SAS SURVEYSELECT default.
\item \code{"down"}: Round down (floor).
\item \code{"nearest"}: Round to nearest integer (standard rounding).
}

This parameter only affects designs using \code{frac} to specify the sampling
rate. When \code{n} is specified directly, no rounding occurs.}

\item{control}{<\code{\link[dplyr:dplyr_data_masking]{data-masking}}> Variables for
sorting the frame before selection. Control sorting provides implicit
stratification, which is particularly effective with systematic and
sequential sampling methods. Can be:
\itemize{
\item A single variable: \code{control = region}
\item Multiple variables: \code{control = c(region, district)}
\item With \code{\link[=serp]{serp()}} for serpentine sorting: \code{control = serp(region, district)}
\item With \code{\link[dplyr:desc]{dplyr::desc()}} for descending: \code{control = c(region, desc(population))}
\item Mixed: \code{control = c(region, serp(district, commune), desc(size))}
}

When stratification is also specified, control sorting is applied within
each stratum. See the section "Control Sorting" below for details.}

\item{certainty_size}{For PPS methods, units with MOS >= this value
are selected with certainty (probability = 1). Can be:
\itemize{
\item A scalar: same threshold for all strata
\item A data frame: stratum-specific thresholds with stratification columns
\itemize{
\item \code{certainty_size} column
}
}

Certainty units are removed from the frame before probability sampling,
and the remaining sample size is reduced accordingly.
Mutually exclusive with \code{certainty_prop}.
Equivalent to SAS SURVEYSELECT \verb{CERTSIZE=} option.}

\item{certainty_prop}{For PPS methods, units whose MOS proportion
(MOS_i / sum(MOS)) >= this value are selected with certainty. Can be:
\itemize{
\item A scalar between 0 and 1 (exclusive): same threshold for all strata
\item A data frame: stratum-specific thresholds with stratification columns
\itemize{
\item \code{certainty_prop} column
}
}

Uses iterative selection: after removing certainty units, proportions are
recomputed and the check is repeated until no new units qualify.
Mutually exclusive with \code{certainty_size}.
Equivalent to SAS SURVEYSELECT \verb{CERTSIZE=P=} option.}
}
\value{
A modified \code{sampling_design} object with selection parameters specified.
}
\description{
\code{draw()} specifies how units are selected: sample size, sampling fraction,
selection method, and measure of size for PPS sampling. Every stage in a
sampling design must end with \code{draw()}.
}
\details{
\subsection{Selection Methods}{
\subsection{Equal Probability Methods}{\tabular{llll}{
   Method \tab Replacement \tab Sample Size \tab Notes \cr
   \code{srswor} \tab Without \tab Fixed \tab Standard SRS \cr
   \code{srswr} \tab With \tab Fixed \tab Allows duplicates \cr
   \code{systematic} \tab Without \tab Fixed \tab Periodic selection \cr
   \code{bernoulli} \tab Without \tab Random \tab Each unit selected independently \cr
}

}

\subsection{PPS Methods}{\tabular{llll}{
   Method \tab Replacement \tab Sample Size \tab Notes \cr
   \code{pps_systematic} \tab Without \tab Fixed \tab Simple, some bias \cr
   \code{pps_brewer} \tab Without \tab Fixed \tab Fast, π_ij > 0 \cr
   \code{pps_maxent} \tab Without \tab Fixed \tab Highest entropy, π_ij available \cr
   \code{pps_poisson} \tab Without \tab Random \tab PPS analog of Bernoulli \cr
   \code{pps_multinomial} \tab With \tab Fixed \tab Any hit count, Hansen-Hurwitz \cr
   \code{pps_chromy} \tab Min. repl. \tab Fixed \tab SAS default PPS_SEQ \cr
}

}

}

\subsection{Parameter Requirements}{\tabular{llll}{
   Method \tab \code{n} \tab \code{frac} \tab \code{mos} \cr
   \code{srswor} \tab ✓ \tab or ✓ \tab — \cr
   \code{srswr} \tab ✓ \tab or ✓ \tab — \cr
   \code{systematic} \tab ✓ \tab or ✓ \tab — \cr
   \code{bernoulli} \tab — \tab ✓ \tab — \cr
   \code{pps_systematic} \tab ✓ \tab or ✓ \tab ✓ \cr
   \code{pps_brewer} \tab ✓ \tab or ✓ \tab ✓ \cr
   \code{pps_maxent} \tab ✓ \tab — \tab ✓ \cr
   \code{pps_poisson} \tab — \tab ✓ \tab ✓ \cr
   \code{pps_multinomial} \tab ✓ \tab or ✓ \tab ✓ \cr
   \code{pps_chromy} \tab ✓ \tab or ✓ \tab ✓ \cr
}

}

\subsection{Fixed vs Random Sample Size Methods}{

Methods with \strong{fixed sample size} (\code{srswor}, \code{srswr}, \code{systematic}, \code{pps_systematic},
\code{pps_brewer}, \code{pps_maxent}, \code{pps_multinomial}) accept either \code{n} or \code{frac}. When \code{frac}
is provided, the sample size is computed based on the \code{round} parameter (default: ceiling).

Methods with \strong{random sample size} (\code{bernoulli}, \code{pps_poisson}) require \code{frac} only.
These methods perform independent selection trials for each unit, so the final sample
size is a random variable—not a fixed count. Specifying \code{n} would be misleading since
the method cannot guarantee exactly \code{n} selections.
}

\subsection{Custom Allocation with Data Frames}{

For stratum-specific sample sizes or rates, pass a data frame to \code{n} or \code{frac}.
The data frame must contain:
\itemize{
\item All stratification variable columns (matching those in \code{stratify_by()})
\item An \code{n} column (for sizes) or \code{frac} column (for rates)
}
}

\subsection{Certainty Selection}{

In PPS sampling, very large units can have theoretical inclusion probabilities
exceeding 1. Certainty selection handles this by selecting such units with
probability 1 before sampling the remainder. The output includes a \code{.certainty_k}
column (where \code{k} is the stage number) indicating which units were certainty selections.

For stratum-specific thresholds, pass a data frame containing:
\itemize{
\item All stratification variable columns
\item A \code{certainty_size} or \code{certainty_prop} column
}
}

\subsection{Control Sorting}{

Control sorting orders the sampling frame before selection, providing implicit
stratification. This is particularly effective with systematic and sequential
methods (\code{systematic}, \code{pps_systematic}, \code{pps_chromy}), where it ensures the
sample spreads evenly across the sorted variables.

\strong{Serpentine vs Nested Sorting:}
\itemize{
\item \strong{Nested} (default): Standard ascending sort by each variable in order.
Use \code{control = c(var1, var2, var3)}.
\item \strong{Serpentine}: Alternating direction that minimizes "jumps" between
adjacent units. Use \code{control = serp(var1, var2, var3)}.
}

Serpentine sorting makes nearby observations more similar by reversing
direction at each hierarchy level. For geographic hierarchies, this means
the last district of region 1 is adjacent to the last district of region 2.

\strong{Combining with Explicit Stratification:}
When both \code{stratify_by()} and \code{control} are used, sorting is applied within
each stratum. This allows explicit stratification for variance control
combined with implicit stratification for sample spread.
}
}
\examples{
# Simple random sample of 100 facilities
sampling_design() |>
  draw(n = 100) |>
  execute(kenya_health, seed = 1)

# Systematic sample of 10\%
sampling_design() |>
  draw(frac = 0.10, method = "systematic") |>
  execute(kenya_health, seed = 123)

# PPS sample of schools using enrollment
sampling_design() |>
  cluster_by(school_id) |>
  draw(n = 50, method = "pps_brewer", mos = enrollment) |>
  execute(tanzania_schools, seed = 42)

# Bernoulli sampling (random sample size, expected ~5\%)
sampling_design() |>
  draw(frac = 0.05, method = "bernoulli") |>
  execute(nigeria_business, seed = 1234)

# Stratified with different sizes per stratum (data frame)
facility_sizes <- data.frame(
  facility_type = c("Clinic", "Dispensary", "Health Centre",
                    "Sub-County Hospital", "County Hospital",
                    "Referral Hospital", "Maternity Home"),
  n = c(30, 40, 35, 25, 20, 10, 15)
)
sampling_design() |>
  stratify_by(facility_type) |>
  draw(n = facility_sizes) |>
  execute(kenya_health, seed = 123)

# Stratified with different rates per stratum (named vector)
sampling_design() |>
  stratify_by(size_class) |>
  draw(frac = c(Micro = 0.01, Small = 0.05, Medium = 0.20, Large = 0.50)) |>
  execute(nigeria_business, seed = 42)

# Neyman allocation with minimum 2 per stratum (for variance estimation)
sampling_design() |>
  stratify_by(region, alloc = "neyman", variance = niger_eas_variance) |>
  draw(n = 150, min_n = 2) |>
  execute(niger_eas, seed = 2026)

# Proportional allocation with min and max bounds
sampling_design() |>
  stratify_by(region, alloc = "proportional") |>
  draw(n = 200, min_n = 10, max_n = 50) |>
  execute(niger_eas, seed = 42)

# Control sorting with serpentine ordering (implicit stratification)
sampling_design() |>
  draw(n = 100, method = "systematic",
       control = serp(region, department)) |>
  execute(niger_eas, seed = 42)

# Control sorting with nested (standard) ordering
sampling_design() |>
  draw(n = 100, method = "systematic",
       control = c(region, department)) |>
  execute(niger_eas, seed = 42)

# Combined explicit stratification with control sorting within strata
sampling_design() |>
  stratify_by(strata) |>
  draw(n = 50, method = "systematic",
       control = serp(region, department)) |>
  execute(niger_eas, seed = 42)

# PPS with certainty selection (absolute threshold)
# Large EAs selected with certainty, rest sampled with PPS
sampling_design() |>
  stratify_by(region) |>
  draw(n = 100, method = "pps_brewer", mos = hh_count,
       certainty_size = 500) |>
  execute(niger_eas, seed = 42)

# PPS with certainty selection (proportional threshold)
# EAs with >= 10\% of stratum total selected with certainty
sampling_design() |>
  stratify_by(region) |>
  draw(n = 100, method = "pps_systematic", mos = hh_count,
       certainty_prop = 0.10) |>
  execute(niger_eas, seed = 42)

# Stratum-specific certainty thresholds (data frame)
cert_thresholds <- data.frame(
  region = c("Agadez", "Diffa", "Dosso", "Maradi",
             "Niamey", "Tahoua", "Tillaberi", "Zinder"),
  certainty_size = c(1000, 500, 600, 700, 300, 800, 650, 750)
)
sampling_design() |>
  stratify_by(region) |>
  draw(n = 100, method = "pps_brewer", mos = hh_count,
       certainty_size = cert_thresholds) |>
  execute(niger_eas, seed = 42)

}
\seealso{
\code{\link[=sampling_design]{sampling_design()}} for creating designs,
\code{\link[=stratify_by]{stratify_by()}} for stratification,
\code{\link[=cluster_by]{cluster_by()}} for clustering,
\code{\link[=execute]{execute()}} for running designs,
\code{\link[=serp]{serp()}} for serpentine sorting
}
