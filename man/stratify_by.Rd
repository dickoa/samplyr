% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stratify.R
\name{stratify_by}
\alias{stratify_by}
\title{Define Stratification}
\usage{
stratify_by(
  .data,
  ...,
  alloc = NULL,
  variance = NULL,
  cost = NULL,
  cv = NULL,
  importance = NULL,
  power = NULL
)
}
\arguments{
\item{.data}{A \code{sampling_design} object (piped from \code{\link[=sampling_design]{sampling_design()}} or
\code{\link[=add_stage]{add_stage()}}).}

\item{...}{Stratification variables specified as bare column names.}

\item{alloc}{Character string specifying the allocation method. One of:
\itemize{
\item \code{NULL} (default): No allocation; \code{n} in \code{\link[=draw]{draw()}} is per stratum
\item \code{"equal"}: Equal allocation across strata
\item \code{"proportional"}: Proportional to stratum size
\item \code{"neyman"}: Neyman optimal allocation (requires \code{variance})
\item \code{"optimal"}: Cost-variance optimal allocation (requires \code{variance} and \code{cost})
\item \code{"power"}: Power allocation (requires \code{cv} and \code{importance})
}}

\item{variance}{Stratum variances for Neyman or optimal allocation.
Either a data frame with columns for all stratification variables plus
a \code{var} column, or a named numeric vector (when using a single
stratification variable) where names correspond to stratum levels.
For named vectors, names must match the values in the stratification
column (for example \code{c(A = 1.2, B = 0.8)}).}

\item{cost}{Stratum costs for optimal allocation.
Either a data frame with columns for all stratification variables plus
a \code{cost} column, or a named numeric vector (when using a single
stratification variable) where names correspond to stratum levels.
For named vectors, names must match the values in the stratification
column.}

\item{cv}{Stratum coefficients of variation (\eqn{C_h}) for power allocation.
Either a data frame with stratification columns plus a \code{cv} column, or
a named numeric vector for a single stratification variable (names are
stratum levels).}

\item{importance}{Stratum importance measure (\eqn{X_h}) for power allocation.
Either a data frame with stratification columns plus an \code{importance}
column, or a named numeric vector for a single stratification variable
(names are stratum levels).}

\item{power}{Power exponent \eqn{q} for power allocation.
Must satisfy \eqn{0 \le q \le 1}. Defaults to \code{0.5}.}
}
\value{
A modified \code{sampling_design} object with stratification specified.
}
\description{
\code{stratify_by()} specifies stratification variables and optional allocation
methods for a sampling design. Stratification ensures representation from
all subgroups defined by the stratification variables.
}
\details{
\subsection{Allocation Methods}{

When no \code{alloc} is specified, the \code{n} parameter in \code{\link[=draw]{draw()}} is interpreted
as the sample size \emph{per stratum}. When an \code{alloc} method is specified,
\code{n} becomes the \emph{total} sample size to be distributed according to the
allocation method.
\subsection{Equal Allocation}{

Each stratum receives n/H units, where H is the number of strata.
}

\subsection{Proportional Allocation}{

Each stratum receives \eqn{n \times N_h/N}{n * N_h/N} units, where \eqn{N_h} is the stratum
population size and N is the total population size.
}

\subsection{Neyman Allocation}{

Minimizes variance for fixed sample size. Each stratum receives:
\eqn{n \times (N_h \times S_h) / \sum(N_h \times S_h)}{n * (N_h * S_h) / sum(N_h * S_h)}
where S_h is the stratum standard deviation.
}

\subsection{Optimal Allocation}{

Minimizes variance for fixed cost (or cost for fixed variance).
Each stratum receives:
\eqn{n \times (N_h \times S_h / \sqrt{C_h}) / \sum(N_h \times S_h / \sqrt{C_h})}{n * (N_h * S_h / sqrt(C_h)) / sum(N_h * S_h / sqrt(C_h))}
where C_h is the per-unit cost in stratum h.
}

\subsection{Power Allocation}{

Power allocation (Bankier, 1988) is a compromise allocation:
\eqn{n_h \propto C_h \times X_h^q}, where \eqn{C_h} is stratum CV, \eqn{X_h}
is a stratum importance measure, and \eqn{q \in [0, 1]}.
}

\subsection{Custom Allocation}{

For custom stratum-specific sample sizes or rates, pass a data frame
directly to the \code{n} or \code{frac} argument in \code{\link[=draw]{draw()}}. The data frame must
contain columns for all stratification variables plus an \code{n} or \code{frac} column.
}

\subsection{Auxiliary Input Formats (\code{variance}, \code{cost}, \code{cv}, \code{importance})}{
\itemize{
\item With \strong{one} stratification variable, you may use a named vector
(e.g., \code{variance = c(A = 1.2, B = 0.8)}).
\item With \strong{multiple} stratification variables, you must use a data frame
containing all stratification columns plus the value column.
}
}

}
}
\section{Data Frame Requirements}{

Auxiliary data frames (\code{variance}, \code{cost}) must contain:
\itemize{
\item All stratification variable columns (used as join keys)
\item The appropriate value column (\code{var} or \code{cost})
}
}

\examples{
# Simple stratification: 20 EAs per region
sampling_design() |>
  stratify_by(region) |>
  draw(n = 20) |>
  execute(niger_eas, seed = 1234)

# Proportional allocation across regions
sampling_design() |>
  stratify_by(region, alloc = "proportional") |>
  draw(n = 200) |>
  execute(niger_eas, seed = 123)

# Neyman allocation using pre-computed variances
sampling_design() |>
  stratify_by(region, alloc = "neyman", variance = niger_eas_variance) |>
  draw(n = 200) |>
  execute(niger_eas, seed = 12)

# Optimal allocation considering both variance and cost
sampling_design() |>
  stratify_by(region, alloc = "optimal",
              variance = niger_eas_variance,
              cost = niger_eas_cost) |>
  draw(n = 200) |>
  execute(niger_eas, seed = 1)

# Power allocation (Bankier, 1988)
sampling_design() |>
  stratify_by(
    region,
    alloc = "power",
    cv = data.frame(
      region = levels(niger_eas$region),
      cv = c(0.40, 0.35, 0.20, 0.18, 0.10, 0.22, 0.25, 0.30)
    ),
    importance = data.frame(
      region = levels(niger_eas$region),
      importance = c(20, 25, 60, 80, 120, 70, 65, 90)
    ),
    power = 0.5
  ) |>
  draw(n = 200) |>
  execute(niger_eas, seed = 7)

# Custom sample sizes per stratum using a data frame
custom_sizes <- data.frame(
  region = levels(niger_eas$region),
  n = c(15, 20, 30, 35, 25, 30, 25, 20)
)
sampling_design() |>
  stratify_by(region) |>
  draw(n = custom_sizes) |>
  execute(niger_eas, seed = 2026)

# Multiple stratification variables
sampling_design() |>
  stratify_by(region, strata, alloc = "proportional") |>
  draw(n = 300) |>
  execute(niger_eas, seed = 2025)

}
\seealso{
\code{\link[=sampling_design]{sampling_design()}} for creating designs,
\code{\link[=draw]{draw()}} for specifying sample sizes,
\code{\link[=cluster_by]{cluster_by()}} for cluster sampling
}
