% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/execute.R
\name{execute}
\alias{execute}
\title{Execute a Sampling Design}
\usage{
execute(.data, ..., stages = NULL, seed = NULL, panels = NULL)
}
\arguments{
\item{.data}{A \code{sampling_design} object, or a \code{tbl_sample} object
for continuation (multi-phase or multi-stage with separate frames).}

\item{...}{Data frame(s) to sample from. For single-stage designs, provide
one frame. For multi-stage designs with separate frames, provide frames
in stage order.}

\item{stages}{Integer vector specifying which stage(s) to execute.
Default (\code{NULL}) executes all remaining stages.}

\item{seed}{Integer random seed for reproducibility.}

\item{panels}{Integer number of rotation groups (panels) to partition the
sample into. Each panel is a representative subsample created by systematic
interleaving within strata. The output includes a \code{.panel} column with
values 1 through \code{panels}. Default \code{NULL} means no panel partitioning.}
}
\value{
A \code{tbl_sample} object (a data frame subclass with sampling
metadata). Contains the selected units plus:
\itemize{
\item \code{.sample_id}: Unique identifier for each sampled unit
\item \code{.weight}: Sampling weight (1/probability)
\item \code{.weight_1}, \code{.weight_2}, ...: Per-stage sampling weights
(\eqn{1/\pi_i^{(k)}}{1/pi_i(k)}). The product of all per-stage
weights equals \code{.weight}.
\item \code{.fpc_1}, \code{.fpc_2}, ...: Per-stage finite population correction
values. The meaning depends on the method and context:
\itemize{
\item \strong{Equal-probability WOR} (srswor, systematic): \eqn{N_h} (stratum
population size), or \eqn{N} if unstratified. The sampling fraction
\eqn{f = n / N} is derived from this at variance-estimation time.
\item \strong{PPS WOR} (pps_brewer, pps_cps, etc.): \eqn{N_h} (stratum
population size), converted to \eqn{\pi_i = 1/w_i}{pi_i = 1/w_i}
at survey export, because \code{survey::svydesign()} expects inclusion
probabilities for unequal-probability stages.
\item \strong{Clustered stages}: the number of clusters in the
stratum/group, not the number of ultimate units.
\item \strong{WR / PMR} (srswr, pps_multinomial, pps_chromy): \eqn{\infty}{Inf}.
With-replacement designs have no finite population correction;
variance is estimated via the Hansen--Hurwitz formula.
In a multi-stage design, each stage has its own \code{.fpc_k}. At survey
export (\code{as_svydesign()}), these are assembled into a multi-level FPC
formula (e.g., \code{~ .fpc_1 + .fpc_2}).
}
\item \code{.draw_1}, \code{.draw_2}, ...: Draw index per stage (WR/PMR methods only).
Each row represents one independent draw; the draw index identifies
which with-replacement selection the row came from.
\item \code{.certainty_1}, \code{.certainty_2}, ...: Whether each unit was a certainty
selection (PPS methods with certainty thresholds only)
\item \code{.panel}: Panel assignment (only when \code{panels} is specified)
\item Stage and stratum identifiers as appropriate
}
}
\description{
\code{execute()} runs a sampling design against one or more data frames,
producing a sampled dataset with appropriate weights and metadata.
}
\details{
\subsection{Execution Patterns}{
\subsection{Single-Stage Execution}{

\preformatted{
design |> execute(frame, seed = 1)
}
}

\subsection{Multi-Stage with Single Frame}{

For hierarchical data where all stages are in one frame:
\preformatted{
design |> execute(frame, seed = 2025)
}
The frame must contain all clustering variables and respect nesting.
}

\subsection{Multi-Stage with Multiple Frames}{

When each stage has its own frame:
\preformatted{
design |> execute(frame1, frame2, frame3, seed = 424)
}
Frames are matched to stages by position.
}

\subsection{Partial Execution (Operational Sampling)}{

Execute only specific stages:
\preformatted{
selected_eas <- design |> execute(ea_frame, stages = 1, seed = 42)
# ... fieldwork: listing in selected EAs ...
sample <- selected_eas |> execute(listing_frame, seed = 43)
}
}

\subsection{Multi-Phase (Continuation)}{

When \code{.data} is a \code{tbl_sample}, sampling continues from that sample:
\preformatted{
phase1 <- design1 |> execute(frame, seed = 42)
# ... add screening data to phase1 ...
phase2 <- design2 |> execute(phase1_updated, seed = 123)
}
Weights compound automatically in multi-phase designs.
}

}

\subsection{Weight Calculation}{

The \code{.weight} column is always the inverse of the inclusion probability.
For all methods the per-stage weight is \eqn{w_i^{(k)} = 1 / \pi_i^{(k)}}{w_i(k) = 1 / pi_i(k)}:
\itemize{
\item \strong{SRS}: \eqn{w_i = N / n}{w = N/n}, constant for all units.
\item \strong{Stratified SRS}: \eqn{w_i = N_h / n_h}{w = N_h/n_h} within stratum \eqn{h}.
\item \strong{PPS WOR}: \eqn{w_i = 1 / \pi_i}{w_i = 1/pi_i} where
\eqn{\pi_i}{pi_i} is computed from the measure of size by
\code{sondage::inclusion_prob()}. Varies across units.
\item \strong{WR / PMR}: \eqn{w_i = 1 / p_i}{w_i = 1/p_i} where \eqn{p_i}{p_i} is
the single-draw selection probability. Each draw is one row; a unit
selected \eqn{k} times appears \eqn{k} times, each with the same weight.
}
\subsection{Multi-stage weight compounding}{

In a \eqn{K}-stage design, the overall weight for unit \eqn{i} is the
product of per-stage weights:
\deqn{w_i = \prod_{k=1}^{K} w_i^{(k)} = \prod_{k=1}^{K} \frac{1}{\pi_i^{(k \mid S^{(k-1)})}}}
where \eqn{\pi_i^{(k \mid S^{(k-1)})}}{pi_i(k | S(k-1))} is the
conditional inclusion probability at stage \eqn{k}, given the set of
clusters selected at all prior stages. For example, in a two-stage design
where 5 of 30 EAs are selected in a region (stage 1) and 12 of 50
households are listed within each selected EA (stage 2):
\deqn{w_i = \frac{30}{5} \times \frac{50}{12} = 6 \times 4.17 = 25}
The \code{.weight} column always equals the product of \code{.weight_1}, \code{.weight_2},
etc. Per-stage weights are preserved for diagnostics and for survey
export.
}

\subsection{Multi-phase weight compounding}{

When \code{.data} is itself a \code{tbl_sample} (two-phase sampling), the
phase-1 inclusion probability is already reflected in the input weights.
The final \code{.weight} is the product of phase-1 and phase-2 weights:
\deqn{w_i = w_i^{(\text{phase 1})} \times w_i^{(\text{phase 2} \mid \text{phase 1})}}
This ensures the Horvitz--Thompson estimator
\eqn{\hat{Y} = \sum_S w_i \, y_i}{Y-hat = sum(w_i * y_i)} is unbiased
for the population total.
}

}

\subsection{Panel Partitioning}{

When \code{panels} is specified, the sample is partitioned into non-overlapping
rotation groups suitable for rotating panel surveys. Each panel is a
representative subsample created by systematic interleaving within strata.

Assignment is deterministic (not random): within each stratum, units are
assigned round-robin to panels 1, 2, ..., k. This ensures each panel has
approximately equal representation from every stratum. The quality of panel
balance benefits from \code{control} sorting in \code{draw()}, which determines the
order of units before interleaving.

For multi-stage designs, panels are assigned at stage 1 (PSU level).
All units within a PSU inherit the PSU's panel assignment.

Weights are not adjusted for panel membership. They reflect the full-sample
inclusion probability. When analysing a single panel, multiply weights by
\code{panels} to obtain per-panel weights.
}
}
\examples{
# Basic SRS execution
sample <- sampling_design() |>
  draw(n = 100) |>
  execute(bfa_eas, seed = 1234)
sample

# Stratified execution with proportional allocation
sample <- sampling_design() |>
  stratify_by(region, alloc = "proportional") |>
  draw(n = 300) |>
  execute(bfa_eas, seed = 5789)
table(sample$region)

# Two-stage cluster sample execution
zwe_frame <- zwe_eas |>
  dplyr::mutate(district_hh = sum(households), .by = district)

sample <- sampling_design() |>
  add_stage(label = "Districts") |>
    cluster_by(district) |>
    draw(n = 20, method = "pps_brewer", mos = district_hh) |>
  add_stage(label = "EAs") |>
    draw(n = 10) |>
  execute(zwe_frame, seed = 3)
length(unique(sample$district))  # 20 districts selected

# Partial execution: stage 1 only
design <- sampling_design() |>
  add_stage(label = "EAs") |>
    stratify_by(region) |>
    cluster_by(ea_id) |>
    draw(n = 5, method = "pps_brewer", mos = households) |>
  add_stage(label = "Households") |>
    draw(n = 12)

# Execute only stage 1 to get selected EAs
selected_eas <- execute(design, bfa_eas, stages = 1, seed = 2)
nrow(selected_eas)  # Number of selected EAs

# Rotating panel: 4 rotation groups
sample <- sampling_design() |>
  stratify_by(region) |>
  draw(n = 200) |>
  execute(bfa_eas, seed = 1, panels = 4)
table(sample$.panel)  # ~50 per panel

}
\seealso{
\code{\link[=sampling_design]{sampling_design()}} for creating designs,
\code{\link[=is_tbl_sample]{is_tbl_sample()}} for testing results,
\code{\link[=get_design]{get_design()}} for extracting metadata
}
